<!DOCTYPE html>
<!-- <html lang="zh-Hant" data-bs-theme="dark"> -->
<html data-bs-theme="dark"></html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title id="pagetitle">文字內容</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    /* 全站暗色 */
    body{background:#212529;color:#f8f9fa}

    /* 導覽列（暗色＋細邊線） */
    .navbar{border-bottom:1px solid rgba(255,255,255,.15)}

    /* 內文容器 */
    #output{
      white-space:pre-wrap; word-wrap:break-word;
      background:#1b1f22; color:#e9ecef;
      border:1px solid rgba(255,255,255,.15);
    }

    /* Sticky 表頭（若之後加表格用得到） */
    .table thead th{position:sticky; top:0; z-index:1; background:#1b1f22}

    /* 控制按鈕 hover + 點擊彈跳動畫 */
    .btn, .form-select, .form-control{
      transition:transform .08s ease, background-color .2s ease, box-shadow .2s ease;
    }
    .btn:hover{filter:brightness(1.1)}
    .btn:active{transform:scale(1.03)}
    @media (prefers-reduced-motion: reduce){
      .btn, .form-select, .form-control{transition:none}
    }

    /* 暗色表單外觀 */
    .form-select, .form-control{
      background:#1b1f22; color:#e9ecef; border:1px solid rgba(255,255,255,.15);
    }
    .form-select:focus, .form-control:focus{
      border-color:var(--bs-primary); box-shadow:0 0 0 .2rem rgba(var(--bs-primary-rgb),.25);
    }

    /* 範圍滑桿在暗色下的可視性（選擇性） */
    input[type="range"]{accent-color:var(--bs-primary)}
  </style>
</head>
<body>
  <!-- 導覽列（暗色） -->
  <nav class="navbar navbar-dark bg-dark">
    <div class="container d-flex justify-content-start">
      <button id="backBtn" class="btn btn-outline-light btn-sm">返回</button>
      <span class="navbar-brand ms-3 mb-0 h1" id="title">文字檔內容</span>
    </div>
  </nav>

  <div class="container py-4">
    <!-- 朗讀控制列 -->
    <div class="d-flex flex-wrap justify-content-between align-items-end gap-2 mb-2">
      <div class="d-flex flex-wrap align-items-center gap-2 ms-auto">
        <select id="voiceSelect" class="form-select form-select-sm" style="min-width:220px">
          <option value="">（載入可用音色中…）</option>
        </select>
        <label class="form-label mb-0 small">
          速率
          <input id="rate" type="range" min="0.5" max="2" step="0.1" value="1" class="form-range" style="width:110px">
        </label>
        <label class="form-label mb-0 small">
          音調
          <input id="pitch" type="range" min="0.5" max="2" step="0.1" value="1" class="form-range" style="width:110px">
        </label>
        <div class="btn-group">
          <button id="playBtn"  class="btn btn-primary btn-sm">播放</button>
          <button id="pauseBtn" class="btn btn-outline-light btn-sm">暫停</button>
          <button id="resumeBtn" class="btn btn-outline-light btn-sm">繼續</button>
          <button id="stopBtn" class="btn btn-outline-danger btn-sm">停止</button>
        </div>
      </div>
    </div>

    <div id="output" class="border rounded p-3">載入中...</div>
  </div>

  <script>
    // ====== 返回鍵 ======
    document.getElementById("backBtn").addEventListener("click", () => history.back());

    // ====== 讀檔 ======
    const params = new URLSearchParams(location.search);
    const file = params.get("file") || "text1.txt";
    const outEl = document.getElementById("output");
    const titleEl = document.getElementById("title");
    titleEl.textContent = file.includes("ans") ? "解答內容" : "題目內容";

    fetch("content/" + encodeURIComponent(file))
      .then(res => { if (!res.ok) throw new Error("HTTP " + res.status); return res.text(); })
      .then(txt => { outEl.textContent = txt; window.scrollTo({ top: 0, behavior: "instant" }); })
      .catch(err => { outEl.textContent = "讀取失敗：" + err.message; });

    // ====== 朗讀控制 ======
    const synth = window.speechSynthesis;
    const voiceSelect = document.getElementById("voiceSelect");
    const rateEl = document.getElementById("rate");
    const pitchEl = document.getElementById("pitch");
    const playBtn = document.getElementById("playBtn");
    const pauseBtn = document.getElementById("pauseBtn");
    const resumeBtn = document.getElementById("resumeBtn");
    const stopBtn = document.getElementById("stopBtn");

    let chunks = [], queue = [], idx = 0, speaking = false;

    function populateVoices() {
      const voices = synth.getVoices();
      const zhPrefer = ["zh-TW", "zh_HANT_TW", "zh-HK", "zh-CN", "zh"];
      voiceSelect.innerHTML = "";
      voices.forEach(v => {
        const opt = document.createElement("option");
        opt.value = v.name;
        opt.textContent = `${v.name} — ${v.lang}`;
        voiceSelect.appendChild(opt);
      });
      const saved = localStorage.getItem("tts_voice");
      if (saved && voices.find(v => v.name === saved)) {
        voiceSelect.value = saved;
      } else {
        const zh = voices.find(v => zhPrefer.some(tag => v.lang.toLowerCase().includes(tag.toLowerCase())));
        voiceSelect.value = zh ? zh.name : (voices[0]?.name || "");
      }
    }
    populateVoices();
    if (typeof speechSynthesis !== "undefined" && speechSynthesis.onvoiceschanged !== undefined) {
      speechSynthesis.onvoiceschanged = populateVoices;
    }

    function splitText(text) {
      const trimmed = text.replace(/\r/g, "").trim();
      if (!trimmed) return [];
      let parts = trimmed.split(/\n{2,}/);
      parts = parts.flatMap(p => p
        .split(/(?<=[。！？!?\.])\s+/)
        .map(s => s.trim())
        .filter(Boolean)
      );
      const MAX_LEN = 180;
      const final = [];
      for (const s of parts) {
        if (s.length <= MAX_LEN) { final.push(s); continue; }
        let buf = "";
        for (const w of s.split(/\s+/)) {
          if ((buf + " " + w).trim().length > MAX_LEN) { final.push(buf.trim()); buf = w; }
          else { buf = (buf ? buf + " " : "") + w; }
        }
        if (buf) final.push(buf.trim());
      }
      return final;
    }

    function buildQueue(text) {
      chunks = splitText(text);
      queue = chunks.map(seg => {
        const u = new SpeechSynthesisUtterance(seg);
        const v = synth.getVoices().find(v => v.name === voiceSelect.value);
        if (v) u.voice = v;
        u.rate = parseFloat(rateEl.value) || 1;
        u.pitch = parseFloat(pitchEl.value) || 1;
        u.lang = u.voice?.lang || "zh-TW";
        u.onend = () => {
          idx++;
          if (idx < queue.length && speaking) synth.speak(queue[idx]);
          else speaking = false;
        };
        return u;
      });
      idx = 0;
    }

    function startSpeak() {
      const text = outEl.textContent || "";
      if (!text.trim()) return;
      synth.cancel();
      speaking = true;
      buildQueue(text);
      if (queue.length) synth.speak(queue[0]);
    }

    playBtn.addEventListener("click", () => {
      if (synth.paused && speaking) { synth.resume(); return; }
      startSpeak();
    });
    pauseBtn.addEventListener("click", () => { if (synth.speaking) synth.pause(); });
    resumeBtn.addEventListener("click", () => { if (synth.paused) synth.resume(); });
    stopBtn.addEventListener("click", () => { speaking = false; synth.cancel(); });

    [rateEl, pitchEl, voiceSelect].forEach(el => {
      el.addEventListener("input", () => {
        localStorage.setItem("tts_voice", voiceSelect.value || "");
        if (speaking || synth.speaking || synth.paused) {
          speaking = true;
          startSpeak();
        }
      });
    });
  </script>
</body>
</html>

